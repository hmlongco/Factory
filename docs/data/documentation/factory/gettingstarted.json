{"seeAlsoSections":[{"title":"The Basics","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Containers","doc:\/\/Factory\/documentation\/Factory\/Scopes","doc:\/\/Factory\/documentation\/Factory\/Migration"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory"},{"type":"text","text":" manages the dependency injection process for a specific object or service and produces an object of the desired type when required."}]},{"anchor":"Defining-a-Factory","level":2,"type":"heading","text":"Defining a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most container-based dependency injection systems require you to define that a given dependency is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory, as you may have guessed from the name, is no exception. Here’s a simple registration that returns a "},{"type":"codeVoice","code":"ServiceType"},{"type":"text","text":" dependency."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        Factory(self) { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To accomplish that we need to extend a Factory "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container"},{"type":"text","text":". Within that container we define a new computed variable of type "},{"type":"codeVoice","code":"Factory<ServiceType>"},{"type":"text","text":". This type must be explicity defined, and is usually a protocol to which the returned dependency conforms."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside the computed variable we construct our Factory, providing it with a refernce to its container (self) and also with a factory closure that’s used tp create an instance of our object when needed. That Factory is then returned to the caller, usually to be evaluated (see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory\/callAsFunction()"},{"type":"text","text":"). Every time we resolve resolve the returned factory we’ll get a new, unique instance of our object."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Like SwftUI Views, Factory structs and modifiers are lightweight and transitory value types. Ther’re created when needed and then immediately discarded once their purpose has been served."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Containers also provide a convenient shortcut that will do the factory creation and binding to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" for us."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        makes { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more examples of Factory definitions that define scopes, use constructor injection, and do parameter passing, see: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Registrations"},{"type":"text","text":"."}]},{"anchor":"Resolving-a-Factory","level":2,"type":"heading","text":"Resolving a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To resolve a Factory and obtain an object or service of the desired type, one simply calls the Factory as s function. Here we use the "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container that’s provided for each and every container type."}]},{"type":"codeListing","syntax":"swift","code":["class ContentViewModel: ObservableObject {","    private let myService = Container.shared.service()","    ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The resolved instance may be brand new or Factory may return a cached value from the specified "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’re passing an instance of a container around to your views or view models, just call it directly."}]},{"type":"codeListing","syntax":"swift","code":["private let service = container.service()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, we could have also uses an @Injected property wrapper and specified a keyPath to the desired dependency."}]},{"type":"codeListing","syntax":"swift","code":["@Injected(\\.service) var service"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unless otherwise specified, the @Injected property wrapper looks for dependencies in the standard shared container provided by Factory, so the above is functionally identical to the "},{"type":"codeVoice","code":"Container.shared.service()"},{"type":"text","text":" example shown earlier. Here’s one pointing to your own container."}]},{"type":"codeListing","syntax":"swift","code":["@Injected(\\MyCustomContainer.service) var service: ServiceType"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more examples see: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions"},{"type":"text","text":"."}]},{"anchor":"Registering-a-new-Factory-closure","level":2,"type":"heading","text":"Registering a new Factory closure"},{"type":"paragraph","inlineContent":[{"type":"text","text":"What happens if we want to change the behavior of a Factory? What if the system requires changes during runtime, or what if we want our factory to provide mocks and testing doubles?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy. Just register a new closure with the existing Factory."}]},{"type":"codeListing","syntax":"swift","code":["container.service.register {","    MockService()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new factory closure overrides the original factory closure and clears the associated scope so that the next time this factory is resolved Factory will evaluate the new closure and return an instance of the newly registered object instead."}]},{"anchor":"Mocking-and-Testing","level":2,"type":"heading","text":"Mocking and Testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we go back and look at our original view model code one might wonder why we’ve gone to all of this trouble? Why not simply say "},{"type":"codeVoice","code":"let myService = MyService()"},{"type":"text","text":" and be done with it?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or keep the container idea, but write something similar to this…"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    static var myService: MyServiceType { MyService() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Well, the primary benefit one gains from using a container-based dependency injection system is that we’re able to change the behavior of the system as needed. Consider the following code:"}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","    @StateObject var model = ContentViewModel()","    var body: some View {","        Text(model.text())","            .padding()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our ContentView uses our view model, which is assigned to a StateObject. Great. But now we want to preview our code. How do we change the behavior of "},{"type":"codeVoice","code":"ContentViewModel"},{"type":"text","text":" so that its "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" dependency isn’t making live API calls during development?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy. Just replace "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" with a mock that also conforms to "},{"type":"codeVoice","code":"MyServiceType"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.myService.register { MockService2() }","        ContentView()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note the line in our preview code where we’re gone back to our container and registered a new closure on our factory. This function overrides the default factory closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now when our preview is displayed "},{"type":"codeVoice","code":"ContentView"},{"type":"text","text":" creates a "},{"type":"codeVoice","code":"ContentViewModel"},{"type":"text","text":" which in turn has a dependency on "},{"type":"codeVoice","code":"myService"},{"type":"text","text":" using shared container."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And when the wrapper asks the factory for an instance of "},{"type":"codeVoice","code":"MyServiceType"},{"type":"text","text":" it now gets a "},{"type":"codeVoice","code":"MockService2"},{"type":"text","text":" instead of the "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" type originally defined."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a powerful concept that lets us reach deep into a chain of dependencies and alter the behavior of a system as needed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing"},{"type":"text","text":" for more information."}]}]}],"variants":[{"paths":["\/documentation\/factory\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"kind":"article","metadata":{"modules":[{"name":"Factory"}],"role":"collectionGroup","title":"Getting Started"},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"topicSections":[{"title":"Examples","abstract":[{"type":"text","text":"Some code samples demonstration various ways to regsiter and resolve Factory’s."}],"identifiers":["doc:\/\/Factory\/documentation\/Factory\/Registrations","doc:\/\/Factory\/documentation\/Factory\/Resolutions"]}],"references":{"doc://Factory/documentation/Factory/Container":{"role":"symbol","title":"Container","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Container"}],"abstract":[{"type":"text","text":"This is the default Container provided for your convenience by Factory."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Container"}],"url":"\/documentation\/factory\/container"},"doc://Factory/documentation/Factory":{"role":"collection","title":"Factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","type":"topic","url":"\/documentation\/factory"},"doc://Factory/documentation/Factory/Factory":{"role":"symbol","title":"Factory","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Factory"}],"abstract":[{"type":"text","text":"A Factory manages the dependency injection process for a specific object or service."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Factory"}],"url":"\/documentation\/factory\/factory"},"doc://Factory/documentation/Factory/Scope":{"role":"symbol","title":"Scope","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Scope"}],"abstract":[{"type":"text","text":"Scopes are used to define the lifetime of resolved dependencies. Factory provides several scope types,"},{"type":"text","text":" "},{"type":"text","text":"including "},{"type":"codeVoice","code":"Singleton"},{"type":"text","text":", "},{"type":"codeVoice","code":"Cached"},{"type":"text","text":", "},{"type":"codeVoice","code":"Graph"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Shared"},{"type":"text","text":"."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Scope"}],"url":"\/documentation\/factory\/scope"},"doc://Factory/documentation/Factory/Factory/callAsFunction()":{"role":"symbol","title":"callAsFunction()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"callAsFunction"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"T"}],"abstract":[{"type":"text","text":"Evaluates the factory and returns an object or service of the desired type. The resolved instance may be brand new or Factory may"},{"type":"text","text":" "},{"type":"text","text":"return a cached value from the specified scope."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory\/callAsFunction()","kind":"symbol","type":"topic","url":"\/documentation\/factory\/factory\/callasfunction()"},"doc://Factory/documentation/Factory/Resolutions":{"role":"article","title":"Sample Resolutions","abstract":[{"type":"text","text":"There are many ways to use Factory to resolve dependencies. Here are a few examples."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions","kind":"article","type":"topic","url":"\/documentation\/factory\/resolutions"},"doc://Factory/documentation/Factory/Migration":{"role":"article","title":"Migration","abstract":[{"type":"text","text":"Moving from 1.x to 2.0"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Migration","kind":"article","type":"topic","url":"\/documentation\/factory\/migration"},"doc://Factory/documentation/Factory/Containers":{"role":"article","title":"Containers","abstract":[{"type":"text","text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","kind":"article","type":"topic","url":"\/documentation\/factory\/containers"},"doc://Factory/documentation/Factory/Registrations":{"role":"article","title":"Sample Registrations","abstract":[{"type":"text","text":"There are many ways to register dependencies with Factory. Here are a few examples."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Registrations","kind":"article","type":"topic","url":"\/documentation\/factory\/registrations"},"doc://Factory/documentation/Factory/Scopes":{"role":"collectionGroup","title":"Scopes","abstract":[{"type":"text","text":"Not everything wants to be a Singleton. Learn the power of Scopes."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","kind":"article","type":"topic","url":"\/documentation\/factory\/scopes"},"doc://Factory/documentation/Factory/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","kind":"article","type":"topic","url":"\/documentation\/factory\/testing"}}}